#!/usr/bin/env bash
# functions - Common functions used by Teefaa components.

# Save trace setting. This is needed beucase "set -o xtrace" is problematic when passing outputs.
XTRACE=$(set +o | grep xtrace)
set +o xtrace

# Check Requirements
CheckReq() {
    # Set counter
    count=0

    # Check required software.
    for cmd in tree mksquashfs mkfs.xfs mkfs.ext4 rsync scp ssh; do
    which $cmd > /dev/null 2>&1
    if [[ $? != "0" ]]; then
        echo "$cmd is not installed."
        let count+=1
    fi
    done
    if [[ $count != "0" ]]; then
        echo "Please install required software..."
        exit 1
    fi
}

# Simply exit if the previous command failed.
FailExit() {
    if [[ $1 != "0" ]]; then
        exit 1
    fi
}

# Create inputs for fdisk to partition the disk with mbr(Master Boot Recorder). 
# This function presumes ``$TOP_DIR/localrc`` is set properly.
function fdisk_input() {
    # Delete existing partitions. If you have any lvm volumes, they can't be deleted.
    # I'll add the deletion function for lvm later.
    for i in {7..1}; do
        echo d
        echo $i
    done

    # Set number of partitons.
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)
    # Create partitions.
    a=1
    while [ ! $a -gt $pnum ]; do
        size=$(eval 'echo ${'$disk$a'[0]}')
        echo n
        echo p
        echo $a
        echo ""
        if [ "$size" != "-1" ]; then
            echo +${size}G
        else
            echo ""
        fi
        let a+=1
    done

    # Add the swap id on the swap partiton and the boot flag on the boot partition.
    a=1
    while [ ! $a -gt $pnum ]; do
        type=$(eval 'echo ${'$disk$a'[1]}')
        mount=$(eval 'echo ${'$disk$a'[2]}')
        if [ "$type" == "swap" ]; then
            echo t
            echo $a
            echo 82
        elif [ "$mount" == "/" ]; then
            echo a
            echo $a
        fi
        let a+=1
    done
    echo w
}

# Create inputs for parted (gpt)
function parted_input() {
    # set gpt label
    parted /dev/$disk --script -- mklabel gpt
    parted /dev/$disk --script -- unit MB
    # Set number of partitons.
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)
    # Create partitions.
    a=1
    while [ ! $a -gt $pnum ]; do
        size=$(eval 'echo ${'$disk$a'[0]}')
        type=$(eval 'echo ${'$disk$a'[1]}')
        mount=$(eval 'echo ${'$disk$a'[2]}')
        if [ "$type" == "bios_grub" ]; then
            parted /dev/$disk --script -- mkpart non-fs 1 3
            parted /dev/$disk --script -- set $a bios_grub on
            sum=3
        elif [ "$type" == "swap" ]; then
            parted /dev/$disk --script -- mkpart swap linux-swap $sum $(echo $sum + ${size}000|bc)
            sum=$(echo $sum + ${size}000|bc)
        elif [[ "$type" != "swap" && "$size" != "-1" ]]; then
            parted /dev/$disk --script -- mkpart primary $sum $(echo $sum + ${size}000|bc)
            if [ "$mount" == "/" ]; then
                parted /dev/$disk --script -- set $a boot on
            fi
            sum=$(echo $sum + ${size}000|bc)
        elif [ "$size" == "-1" ]; then
            parted /dev/$disk --script -- mkpart primary $sum -1
            if [ "$mount" == "/" ]; then
                parted /dev/$disk --script -- set $a boot on
            fi
        fi
        let a+=1
    done
}

# Partition the disk.
Partitioning() {
    # Define the check point message. If the message is written on ``LOGFILE``,
    # it won't redo.
    check_point="Finished partitioning"
    grep "$check_point" $LOGFILE 1>/dev/null
    if [ "$?" != "0" ]; then
        case "$PARTITION_TYPE" in
          mbr )
              fdisk_input > /tmp/fdisk_input
              fdisk /dev/$disk < /tmp/fdisk_input
              echo $(date):  $check_point
              ;;
          gpt )
              parted_input
              echo $(date):  $check_point
              ;;
          none )
              echo $(date):  "PARTITION_TYPE=none is set. Don't partition."
              echo $(date):  $check_point
              ;;
          * )
              echo $(date):  "Error: PARTITION_TYPE isn't set correctly. Check your localrc."
              exit 1
              ;;
        esac
    else
        echo $(date):  "Partitioning is already done so it didn't partition this time."
    fi
}

# Make Filesystem(including Swap).
MakeFilesystem() {
    # Set number of partitons.
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)

    a=1
    while [ ! $a -gt $pnum ]; do
        # Read the value from ``array_FILESYSTEMS``
        fsys=$(eval 'echo ${'$disk$a'[1]}')
        mpoint=$(eval 'echo ${'$disk$a'[2]}')
        # Define the check point message.
        check_point="Finish making $fsys on /dev/$disk$a"
        # Check if the check_point message exists on the log.
        grep "$check_point" $LOGFILE 1>/dev/null
        if [ $? != "0" ]; then
            # Start Making Filesystem.
            case "$fsys" in
               swap )
                  mkswap /dev/$disk$a
                  echo $(date):  $check_point
               ;;
               ext4 )
                  mkfs.ext4 /dev/$disk$a
                  echo $(date):  $check_point
               ;;
               ext3 )
                  mkfs.ext3 /dev/$disk$a
                  echo $(date):  $check_point
               ;;
               xfs )
                  mkfs.xfs -f /dev/$disk$a
                  echo $(date):  $check_point
               ;;
               bios_grub )
                  echo $(date):  Ignore $fsys and do nothing... This is not error.
               ;;
               * )
                  echo $(date):  "Error: The file system type $fsys is not supported. The code supports making ext3, ext4, xfs and swap."
                  exit 1
               ;;
            esac
        # If the check point exists on the log, don't make filesystem.
        else
            echo $(date):  "$fsys is already made on /dev/$disk${a}."
        fi
    let a+=1
    done
}

MountPertition() {
    # Set number of partitons.
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)

    a=1
    while [ ! $a -gt $pnum ]; do
        fsys=$(eval 'echo ${'$disk$a'[1]}')
        mpoint=$(eval 'echo ${'$disk$a'[2]}')
        # Define the check point message.
        check_point="Finish mount /dev/$disk$a on $MNT_ROOT$mpoint"
        # Check if the check_point message exists on the log.
        grep "$check_point" $LOGFILE 1>/dev/null
        if [ $? != "0" ]; then
            # If it's rehearse mode, just rehearse making filesystem.
            if [[ "$fsys" != "swap" && "$MODE" == "rehearse" ]]; then
                echo $(date):  Rehearse: mkdir -p $MNT_ROOT$mpoint
                echo $(date):  Rehearse: mount /dev/sda$a $MNT_ROOT$mpoint
                echo $(date):  Rehearse: $check_point
            # if it's perform mode and swap, make swap.
            elif [[ "$mpoint" != "none" && "$MODE" == "perform" ]]; then
                mkdir -p $MNT_ROOT$mpoint
                mount /dev/$disk$a $MNT_ROOT$mpoint
                echo $(date):  $check_point
            # if it's something else, output unknown error and exit.
            elif [[ "$fsys" == "swap" || "$fsys" == "bios_grub" ]]; then
                echo $(date):  "swap isn't mountable. This isn't error."
            else
                echo $(date):  "Unknown error while making file system, $fsys, $disk$a"
                exit 1
            fi
        # If the check point exists on the log, don't make filesystem.
        else
            echo $(date):  "/dev/$disk$a is already mounted on $MNT_ROOT$mpoint"
        fi
    let a+=1
    done
}

CopyOSImage() {
    # Load the list of image source, and split the list.
    list=$(eval "awk '/$IMAGE_NAME/ {print $'2'}' $IMAGE_LIST")
    set $list

    # ``lockfile`` is for avoiding to use 
    lockfile=lock.bootstrap
    for i; do
        # Devide host and directory.
        rhost=$(echo $i|cut -d: -f1)
        rdir=$(echo $i|cut -d: -f2)

        # Define the message for the check point.
        check_point="Finished copying the OS Image from"
        grep "$check_point" $LOGFILE 1>/dev/null
        if [ $? == "0" ]; then
            echo $(date):  "The image is already copied."
            break
        fi
        if [ "$MODE" == "perform" ]; then
            # Check if $rhost is available to login.
            ssh -n $rhost hostname
            if [ "$?" != "0" ]; then
                echo $(date):  "Error: Can't ssh to ${rhost}. Exit."
                exit 1
            fi
            # Check if $dir/$lockfile exists, then set ``checklock`` as 0 if yes.
            checklock="1"
            ssh -n $rhost ls $lockfile
            if [ "$?" == "0" ]; then
                checklock="0"
            fi
        fi

        # Check if the lockfile exists. If not, perform/rehearse the isntallation.
        if [ "$checklock" != 0 ]; then
            if [ "$MODE" == "perform" ]; then
                echo $(date):  "Start coping the OS Image from $rhost:$rdir"
                # create lock file so that another process not to start installation with the same image source.
                # NOTE: disable this until a bug is fixed.
                #ssh -n $rhost touch $lockfile
                # Copy the image.
                rsync -a --stats --exclude-from=$EXCLUDE_LIST $rhost:$rdir/ $MNT_ROOT
                # If rsync failed, exit.
                if [ "$?" != "0" ]; then
                    echo $(date):  "Copying the image failed for some reason. exit."
                    exit 1
                fi
                # Delete the lockfile.
                ssh -n $rhost rm $lockfile
                # Add log and break the loop.
                echo $(date):  $check_point $rhost:$rdir
                break
            elif [ "$MODE" == "rehearse" ]; then
                echo $(date):  Rehearse copy image:  command: rsync -a --stats --exclude="$lockfile" --exclude-from=$EXCLUDE_LIST $rhost:$rdir/ $MNT_ROOT
                echo $(date):  "Rehearse $check_point $i"
                break
            else
                echo $(date):  "error: function CopyOSImage() Failed."
            fi
        else
            echo $(date): $rhost:$rdir is locked by another bootstrap script. Will try next source.
        fi
    done
}

# GetDistro - determines OS and Version. Returns results in global variables:
#os_DISTRO - vendor name
#os_RELEASE - release
GetDistro() {
    # Figure out which vendor we are
    if [[ -x $(chroot $MNT_ROOT which lsb_release 2>/dev/null) ]]; then
        os_DISTRO=$(chroot $MNT_ROOT lsb_release -i -s)
        os_RELEASE=$(chroot $MNT_ROOT lsb_release -r -s)
        if [[ "SUSE LINUX" =~ $os_VENDOR ]]; then
            chroot $MNT_ROOT lsb_release -d -s | grep -q openSUSE
            if [[ $? -eq 0 ]]; then
               os_DISTRO="openSUSE"
            fi
        fi
    elif [[ -f $MNT_ROOT/etc/redhat-release ]]; then
        # Red Hat Enterprise Linux Server release 5.5 (Tikanga)
        # CentOS release 5.5 (Final)
        # CentOS Linux release 6.0 (Final)
        # Fedora release 16 (Verne)
        temp=$(cat $MNT_ROOT/etc/redhat-release)
        set $temp
        if [[ "$1" == "Red" || "$1" == "Scientific" ]]; then
            os_DISTRO=$1$2
        else
            os_DISTRO=$1
        fi
        for i; do
            if [ "$i" == "release" ]; then
                shift
                os_RELEASE=$1
            fi
            shift
        done        
    fi
    os_DISTRO=$(echo $os_DISTRO|tr '[A-Z]' '[a-z]')
    export os_DISTRO os_RELEASE
}

UpdateDiff() {

    source $TOP_DIR/localrc
    rsync -av $DIFF_DIR/ $MNT_ROOT

    # If ``DIFF_TYPE`` isn't ``general``, replace certain items to proper values.
    if [ "$DIFF_TYPE" != "general" ]; then
        # Get IP address on the external interface by presuming ``GATEWAY`` is on
        # the external network. This isn't a smart way so I'll rethink on this later.
        gw_split=$(echo $GATEWAY |tr '.' ' ')
        set $gw_split
        tf_ipaddr=$(ifconfig -a |grep "inet addr:$1.$2."|awk '{print $2}'|cut -d: -f2)
        # Check if the IP address($ip_addr) is on the address list.
        temp=($(grep $tf_ipaddr $ADDR_LIST))
        if [ "$?" == "0" ]; then
            items=$(head -1 $ADDR_LIST)
            set $items
            a=0
            for i; do
                eval $i='${temp['$a']}'
                let a+=1
            done
            # If the IP address($ip_addr) is on the list, set the hostname.
        else
            # If not, just set the hostname as localhost as the hostname.
            echo $(date):  "Error: the IP address is $tf_ipaddr, but it's not on ${ADDR_LIST} ..."
            exit 1
        fi
        # Move to the root of DIFF_DIR and get the file list.
        cd $DIFF_DIR
        diff_list=$(tree -if)
        if [ "$?" != "0" ]; then
           echo $(date):  Error: tree -if failed at $DIFF_DIR.
           exit 1
        fi
        # For each one on the list, check if it is file, and then replace the words to what it should be.
        set $diff_list
        cd $MNT_ROOT
        for i; do
            if [ -f "$i" ]; then
                temp=$(head -1 $ADDR_LIST)
                set $temp
                for f; do
                   eval 'sed -i -e "s/$DIFF_PREFIX$f/$'$f'/" $i'
                done
            fi
        done
    fi
    
    # Update /etc/fstab. First of all get number of partitions.
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)
    if [ "$?" != "0" ]; then
        echo $(date):  "Error: Can't find ${disk}X on localrc Command failed: grep ^$disk $TOP_DIR/localrc|wc -l"
        exit 1
    fi
    a=1
    while [ ! "$a" -gt "$pnum" ]; do
        unset temp
        temp=($(eval echo '${'$disk$a'[*]}'))
        echo $(date):  "Modifying /etc/fstab. Partition=$disk$a, size=${temp[0]}, type=${temp[1]}, mounting on ${temp[2]}."
        if [ "${temp[1]}" == "swap" ]; then
            echo "/dev/$disk$a   none   swap   sw   0   0" >> $MNT_ROOT/etc/fstab
        elif [[ "${temp[1]}" == "ext4" && "${temp[2]}" != "none" ]] ; then
            echo "/dev/$disk$a   ${temp[2]}   ${temp[1]}   errors=remount-ro   0   1" >> $MNT_ROOT/etc/fstab
            # Update /etc/mtab
            if [[ "${temp[2]}" == "/"  ]]; then
                echo "/dev/$disk$a / ext4 rw 0 0" >> $MNT_ROOT/etc/mtab
            fi
        elif [[ "${temp[1]}" == "ext3" && "${temp[2]}" != "none" ]] ; then
            echo "/dev/$disk$a   ${temp[2]}   ${temp[1]}    defaults   1   1" >> $MNT_ROOT/etc/fstab
            # Update /etc/mtab
            if [[ "${temp[2]}" == "/"  ]]; then
                echo "/dev/$disk$a / ext3 rw 0 0" >> $MNT_ROOT/etc/mtab
            fi
        elif [[ "${temp[1]}" == "xfs" && "${temp[2]}" != "none" ]] ; then
            echo "/dev/$disk$a   ${temp[2]}   ${temp[1]}    defaults,noatime   0   0" >> $MNT_ROOT/etc/fstab
        else
            echo $(date):  "Worning:  unknown file system. didn't write it on /etc/fstab... $disk$a   ${temp[2]}   ${temp[1]} ???"
        fi
        let a+=1
    done

    # Register ssh key.
    echo $(date):  "Register $SSH_PUBKEYS to /root/.ssh/authorized_keys ..."
    mkdir -p $MNT_ROOT/root/.ssh
    chmod 700 $MNT_ROOT/root/.ssh
    echo "$SSH_PUBKEYS" > $MNT_ROOT/root/.ssh/authorized_keys
    if [ "$?" != "0" ]; then
        echo $(date):  "Error: Registering $SSH_PUBKEYS to $MNT_ROOT/root/.ssh/authorized_keys failed."
        exit 1
    fi
    chmod 644 $MNT_ROOT/root/.ssh/authorized_keys

    # If password need to be reset at the first login, go through this process.
    if [ "$PASS_CHANGE" == "yes" ]; then
        chroot $MNT_ROOT usermod -p "" root
        chroot $MNT_ROOT chage -d 0 root
    fi
}

InstallGrub() {
    # Write different process os_DISTRO os_RELEASE   
    pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)
    if [ "$?" != "0" ]; then
        echo $(date):  "Error: Command failed: grep ^$disk|wc -l"
        exit 1
    fi
    a=1
    while [ ! "$a" -gt "$pnum" ]; do
        unset temp
        temp=($(eval echo '${'$disk$a'[*]}'))
        if [ "${temp[2]}" == "/" ]; then
              ROOT_PTR=$disk$a
        fi
        let a+=1
    done
    if [[ "$os_DISTRO" == "ubuntu" || "$os_DISTRO" == "debian" ]]; then
        temp=($(ls -la /dev/disk/by-uuid/ |grep $ROOT_PTR))
        newuuid=${temp[8]}
        echo $(date):  "newuuid=${temp[8]}"
        temp=($(grep "root=UUID=" $MNT_ROOT/boot/grub/grub.cfg|head -1|tr '=' ' '))
        wnum=$(echo ${temp[*]}|wc -w)
        a=0
        while [ ! $a -gt $wnum ]; do
            if [ "${temp[$a]}" == "UUID" ]; then
                olduuid=${temp[$(expr $a + 1)]}
                echo $(date):  "olduuid=${temp[$(expr $a + 1)]}"
            fi
            let a+=1
        done
        sed -i -e "s/$olduuid/$newuuid/" $MNT_ROOT/boot/grub/grub.cfg
        mount -t proc proc $MNT_ROOT/proc
        mount -t sysfs sys $MNT_ROOT/sys
        mount -o bind /dev $MNT_ROOT/dev
        chroot $MNT_ROOT update-grub
        chroot $MNT_ROOT grub-install /dev/$disk
    elif [[ "$os_DISTRO" == "redhat" || "$os_DISTRO" == "centos" || "$os_DISTRO" == "scientificlinux" ]]; then
        # Update (hdX,X) in grub.conf.
        # First of all, Take "hdX,X" and store as ``old``.
        old=$(grep "root (hd" $MNT_ROOT/boot/grub/grub.conf|head -1)
        old=$(echo ${old#*(})
        old=$(echo ${old%*)})

        # Create ``new`` from $ROOT_PTR and $disk. sda=hd0, sdb=hd1...
        a=0; b=1; c=2; d=3; e=4;
        new=hd$(eval echo '$'${disk#*d})
        part=$(expr $(eval 'echo ${ROOT_PTR#'$disk'}') - 1 )
        new="$new,$part"
        # Replace $old to $new.
        sed -i -e "s/$old/$new/g" $MNT_ROOT/boot/grub/grub.conf

        # Update ``root=/dev/XdaY`` in grub.conf.
        for aaa in $(grep "root=" $MNT_ROOT/boot/grub/grub.conf); do
            if [[ $aaa =~ "root=" ]]; then
                echo $aaa > /tmp/temp.txt
                replace=$(sed 's/\//\\\//g' /tmp/temp.txt)
                # Set number of partitons.
                pnum=$(grep ^$disk $TOP_DIR/localrc|wc -l)
                # Create partitions.
                a=1
                while [ ! $a -gt $pnum ]; do
                    mount=$(eval 'echo ${'$disk$a'[2]}')
                    if [ "$mount" == "/" ]; then
                        newroot="root=\/dev\/$disk$a"
                        break
                    fi
                    let a+=1
                done
                sed -i -e "s/$replace/$newroot/g" $MNT_ROOT/boot/grub/grub.conf
            elif [[ $aaa =~ "LVM" ]]; then
                echo $aaa > /tmp/temp.txt
                replace=$(sed 's/\//\\\//g' /tmp/temp.txt)
                sed -i -e "s/$replace//g" $MNT_ROOT/boot/grub/grub.conf
            fi
        done

        # If /boot is on another partition...
        grep "kernel /vmlinuz" $MNT_ROOT/boot/grub/grub.conf > /dev/null 2>&1
        if [[ $? = "0" ]]; then
           sed -i -e "s/vmlinuz/boot\/vmlinuz/" $MNT_ROOT/boot/grub/grub.conf
           sed -i -e "s/initramfs/boot\/initramfs/" $MNT_ROOT/boot/grub/grub.conf
        fi

        # Install Grub
        mount -t proc proc $MNT_ROOT/proc
        mount -t sysfs sys $MNT_ROOT/sys
        mount -o bind /dev $MNT_ROOT/dev
        chroot $MNT_ROOT grub-install /dev/$disk
    fi

    # Reboot if REBOOT is yes.
    if [ "$REBOOT" == "yes" ]; then
        reboot
    fi
}

MakeSnapshot() {
    # Set date.
    DATE=$(date +%Y%m%d)

    echo ""
    echo "Please make sure you have enough free space on $SNAPSHOT_DIR."
    echo "This script compresses the system image with squashfs, but still"
    echo "it needs free space more than in-used space during the process."
    echo "you can check it by df -ha."
    echo ""
    echo -n "Do you want to proceed? (y/n):"
    read answer
    if [[ $answer != "y" ]]; then
        echo "Your answer is not \"y\", stopping the script..."
        sleep 3
        exit 1
    fi

    # Copy the system image.
    mkdir -p $SNAPSHOT_DIR
    echo "Copying your system image to $SNAPSHOT_DIR/_rootimg..."
    echo "It takes several minutes. Go get some coffee..."
    rsync -a --stats --exclude-from=$EXCLUDE_LIST / $SNAPSHOT_DIR/_rootimg
    #rsync -a --stats --one-file-system /sys/ $SNAPSHOT_DIR/_rootimg/sys

    # Pack image.
    echo "Compressing the image..."
    mksquashfs $SNAPSHOT_DIR/_rootimg $SNAPSHOT_DIR/${HOSTNAME}-${DATE}.squashfs -noappend

    # Get size
    actual_size=$(du -sh $SNAPSHOT_DIR/_rootimg | awk '{print $1}')
   
    # Delete rootimg/*
    rm -rf $SNAPSHOT_DIR/_rootimg

    # Gte compressed size
    compressed_size=$(ls -lh $SNAPSHOT_DIR/${HOSTNAME}-${DATE}.squashfs | awk '{print $5}')

    # Print message.
    echo "The OS image has been created as:"
    echo "    $SNAPSHOT_DIR/${HOSTNAME}-${DATE}.squashfs"
    echo "    Actucal size: $actual_size"
    echo "    Compressed size: $compressed_size"
}


MakeCloudImage() {

    if [[ -z $1 || -z $2 ]]; then
       echo ""
       echo "Usage:"
       echo " ./cloudimg.sh </path/to/snapshot.squashfs> <name> <size(MB)>"
       echo ""
       exit 1
    fi
    # Set date
    DATE=$(date +%Y%m%d)

    # Get 
    snapshot=$1
    image_name=$2
    image_size=$3

    echo snapshot=$snapshot, image_name=$image_name, image_size=$image_size

    echo ""
    echo "Please make sure you have enough space on $CLOUDIMG_DIR ."
    echo ""
    echo -n "Do you want to proceed? (y/n):"
    read answer
    if [[ $answer != "y" ]]; then
        echo "Your answer is not \"y\", stopping the script..."
        sleep 3
        exit 1
    fi

    # Change directory
    echo $(date) "Teefaa: Change directory to $CLOUDIMG_DIR"
    mkdir -p $CLOUDIMG_DIR
    FailExit $?
    cd $CLOUDIMG_DIR
    FailExit $?
    # Make image file
    echo "Create image file as ${image_name}.img"
    dd if=/dev/zero of=${image_name}.img bs=1M count=$image_size
    FailExit $?
    # Make File System, and mount it.
    echo "Make filesystem"
    mkfs.ext4 -F ${image_name}.img
    FailExit $?
    # Add label
    echo "Add label"
    tune2fs -L rootfs ${image_name}.img
    FailExit $?
    # Make mount point.
    echo "Make _mnt.img(temp directory for the image)"
    mkdir _mnt.img
    FailExit $?
    # Mount image
    echo "Mount image on _mnt.img"
    mount ${image_name}.img _mnt.img -o loop
    FailExit $?
    # Mount squashfs
    echo "Make _mnt.snapshot(temp directory for the snapshot)"
    mkdir _mnt.snapshot
    FailExit $?
    # Mount snapshot
    echo "Mount snapshot on _mnt.snapshot"
    mount $snapshot _mnt.snapshot -o loop
    FailExit $?
    # Copy images
    echo "Copy snapshot to image file"
    rsync -a --stats _mnt.snapshot/ _mnt.img
    FailExit $?

    # Check OS Distro and Version
    MNT_ROOT="/"
    GetDistro
    
    # Update files for making it work on the Cloud.
    DIFF_DIR=$TOP_DIR/diffs/cloud/$os_DISTRO/$os_RELEASE
    rsync -a --stats $DIFF_DIR/ _mnt.img
    FailExit $?

    # Copy the latest lernel out.
    kernel=$(ls -1t _mnt.snapshot/boot/vmlinuz*|head -1)
    cp $kernel ${image_name}-vmlinuz .
    FailExit $?
    # Copy the latest ramdisk out.
    ramdisk=$(ls -1t _mnt.snapshot/boot/initr*|head -1)
    cp $ramdisk ${image_name}-ramdisk .
    FailExit $?

    # Unmount _mnt.snapshot _mnt.img
    umount _mnt.snapshot _mnt.img
    FailExit $?
    
    # remove _mnt.snapshot _mnt.img
    rm -rf _mnt.snapshot _mnt.img

    # Everything's done.
    echo "Cloud image is ready. Upload it on your Cloud."
}

# Restore xtrace
$XTRACE
